.. index::
   double:  web page; Python
   
Composing Web Pages in Python
=============================

.. _Dynamically-Created-Static:
    
Dynamically Created Static Local Pages from Python
--------------------------------------------------

For the rest of this chapter, the example files will come from the
www directory under the main examples directory you unzipped. I
will refer to example file there as "example www files".

As the overview indicated, dynamic web applications typically
involve getting input from a web page form, processing the input
in a program on the server, and displaying output to a web page.
Introducing all these new ideas at once could be a lot to absorb,
so this section 
uses familiar keyboard input into a regular Python program
and then, like in the final version,
processes the input and produces the final web page output.

Follow this sequence of steps:

#. Open the example www file ``hello.html`` in your browser, to see what
   it looks like.

#. Change your browser view - for instance go back to the previous
   page you displayed.

#. Open the same hello.html file in Kompozer, if that works for you,
   or another editor that will show the html source, as discussed in
   :doc:`htmlsource`.

#. If using Kompozer, switch to the Source view (clicking the Source tab).
   Sometimes you will want to copy HTML text into a Python program.
   For instance, I selected and copied the entire contents of the
   ``hello.html`` source view and pasted it into a multi-line string in
   the Python program shown and discussed below.

#. Careful, note the change from past practice here: Start Python
   *from inside the www directory*.  In Windows you may start Idle with
   the IdleOnWindows shortcut
   that I placed *in the www directory*, not the original example
   directory.

#. Open the www example program ``helloWeb1.py`` in an Idle
   edit window.

#. *Run* it.

You should see a familiar web page appear in your
*default* browser (possibly not the one you have been using). This
is obviously not a very necessary program, since you can select
this page directly in your browser! Still, one step at a time: it
illustrates several useful points. The program is copied below.
*Read* it:

.. literalinclude:: ../examples/www/helloWeb1.py

.. index:: webbrowser module

This program encapsulates two basic operations into the last two
functions that will be used *over and over*. The first,
``strToFile``, has nothing new, it just puts specified text in a
file with a specified name. The second, ``browseLocal``, does more.
It takes specified text (presumably a web page), puts it in a file,
and directly displays the file in your default web browser. It uses the
``open`` function from the ``webbrowser`` module to start the new
page in your web browser.  

The open function here requires the name of a
file or URL.  Since the page is automatically generated by the program
for one-time immediate viewing, it automatically uses 
the same throwaway filename, ``tempBrowseLocal.html``
specified as the default in the keyword parameter.  If you
really want another specific, name you could pass it as a parameter.

In this particular program the text that goes in the file is just
copied from the literal string named ``contents`` in the program.

This is no advance over just opening the file in the browser
directly! Still, it is a start towards the aim of creating web
content dynamically.

An early example in this tutorial displayed the fixed
``Hello World!'`` to the screen. This was later modified in
``hello_you4.py`` to incorporate user input using the string format
method of :ref:`Dictionaries-and-String`, ::

    person = input('Enter your name: ') 
    greeting = 'Hello {person}!'.format(**locals())
    print(greeting)  

Similarly, I can turn the web page contents into a format string,
and insert user data. Load and *run* the www example program
``helloWeb2.py``.

The simple changes from ``helloWeb1.py`` are marked at the
beginning of the file and shown below. I modified the web page text
to contain 'Hello, {person}!' in place of 'Hello, World!',
making the string into a *format* string, which I renamed to the
more appropriate ``pageTemplate``. The changed initial portion with
the literal string and and the main program then becomes

.. literalinclude:: ../examples/www/helloWeb2.py
   :start-after: NEW
   :end-before: def strToFile

Now the line ::

    contents = pageTemplate.format(**locals())   

incorporaties the person's name into the contents for the web page
before saving it to a file and displaying it.

In this case, I stored the literal format string inside the Python
program, but consider a different approach:

Load and *run* the www example program ``helloWeb3.py``. It behaves
exactly like helloWeb2.py, but is slightly different internally -
it does not directly contain the web page template string. Instead
the web page template string is read from the file
``helloTemplate.html``.

Below is the beginning of helloWeb3.py, showing the only new
functions. The first, ``fileToStr``, will be a standard function
used in the future. It is the inverse of ``strToFile``.

The main program obtains the input. In this simple example, the
input is used directly, with little further processing. It is
inserted into the web page, using the file ``helloTemplate.html``
as a format string.

.. literalinclude:: ../examples/www/helloWeb3.py
   :start-after: template
   :end-before: def strToFile

Although ``helloTemplate.html`` is not intended to be viewed by the
user (being a template), you should open it in a browser or web editor 
(Kompozer or ...) to look at it. It is legal to create a web page in a web
page editor with expressions in braces embedded in it! If you look
in the source view in Kompozer or in a web source editor, 
you will see something similar to
the literal string in helloWeb2.py, except the lines are broken up
differently. (This makes no difference in the formatted result,
since in html, all white space is considered the same.)

Back in the Normal mode in Kompozer, or in source mode for any html editor, add  an
extra line of text right after the line "Hello, {person}!".
Then save the file again (under the *same*
name). Run the program ``helloWeb3.py`` again, and see that you
have been able to change the *appearance* of the output without
changing the Python program itself. That is the aim of using the
template html page, allowing the web output formatting to be
managed mostly *independently* from the Python program.

A more complicated but much more common situation is where the
input data is processed and transformed into results somehow, and
these *results*, often along with some of the original input, are
embedded in the output web page that is produced.

As a simple example, load and *run* the www example program
``additionWeb.py``, which uses the template file
``additionTemplate.html``.

The aim in the end of this chapter is to have user input come from
a form on the web rather than the keyboard on a local machine, but
in either case the input is still transformed into results and all
embedded in a web page. To make parts easily reusable, I *obtain*
the input in a *distinct* place from where the input is
*processed*. In keeping with the later situation with web forms,
all input is of string type (using keyboard ``input`` for *now*).

Look at the program. You will see only a few new lines! Because of
the modular design, most of the program is composed of recent
standard functions reused.

The only new code is at the beginning and is shown here:

.. literalinclude:: ../examples/www/additionWeb.py
   :start-after: display
   :end-before: def fileToStr

The input is obtained (via ``input`` for now), and it is processed
into a web page string, and as a separate step it is displayed in a
local web page.

There are a few things to note:

-  All input is strings. Before the numerical calculations, the
   digit strings must be converted to integers.

-  I do calculate (a very simple!) result and use it in the output
   web page.

-  Although it is not in the Python code, an important part of the
   result comes from the web page format string in
   additionTemplate.html, which includes the needed variable names in
   braces, {num1}, {num2}, and {total}.  View it in your browser
   or in a web editor.

When you write your own code, you might modify ``additionWeb.py``,
or you can start from a stripped down skeleton in the example www folder,
``skeletonForWeb.py``, with comments about where
to insert your special code.

We will examine the bottom part of the following diagram later.
The top part outlines the flow of data from string input to
web page in your browser for a regular Python program like
what we have been describing, with the processing outlined in the
middle line.  The parts in the middle will be common to the later
client/server program, that manges input and output with the bottom line,
that we will discuss later.

.. figure:: images/dynamicWebFlow.*
   :align: center
   :alt: image
   :width: 461.25 pt


Again, this last section was somewhat artificial.  You are not in the end
likely to find such programs practical as end products.  However
such programs are reasonable to write and test and they include *almost* all
the code you will need for a more practical (but harder to debug)
CGI program, coming next....


.. _quotientWeb:
    
Quotient Web Exercise
~~~~~~~~~~~~~~~~~~~~~

\* Save ``additionWeb.py`` or ``skeletonForWeb.py``
*as* ``quotientWeb.py``. Modify it to
display the results of a division problem in a web page. 
As in the exercises in Chapter 1,  display a full sentence
labeling the initial data and both the integer quotient and the remainder.
You can
take your calculations from :ref:`QuotientStringEx`.
You should
only need to make Python changes to the ``processInput`` and
``main`` functions. You will also need the HTML for the output page
displayed. Make a web page template file called
``quotientTemplate.html`` and read it into your program.
Turn in both ``quotientWeb.py`` and ``quotientTemplate.html``.

